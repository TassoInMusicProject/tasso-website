<script>
// vim: ts=3
//
//   displayHumdrum({
//      postFunction: addFootnotes
//   });

//////////////////////////////
//
// addFootnotes -- This function is given to the Humdrum Notation Plugin system to run
//    every time the notation is regenerated by verovio.  This function inserts each
//    of the footnotes.  It will try all footnotes, and if the footnote is not on a page
//    it will be ignored.
//

function addFootnotes(id) {
	// clear list of old foot notes
	let footnotes = document.querySelector("#footnotes");
	if (footnotes) {
		footnotes.innerHTML = "";
	} else {
		console.log("CANNOT FIND #FOOTNOTES");
	}

	let svg = document.querySelector("#" + id + "-container svg");
	if (!svg) {
		console.log("CANNOT FIND SVG IMAGE");
		return;
	}

	let emendations = getEmendationsForFootnotes();
	if (!emendations) {
		console.log("CANNOT FIND EMENDATIONS");
		return;
	}

	for (let i=0; i<emendations.length; i++) {
		emendations[i].markText = "*";
		emendations[i].color = "chocolate";
		emendations[i].placement = "above";
		emendations[i].number = i;
		addFootnote(emendations[i], svg, "tooltip");
	}
}



//////////////////////////////
//
// getEmendationsForFootnotes --
//

function getEmendationsForFootnotes() {
	let list = document.querySelectorAll("ul.emended");
	if ((!list) || (list.length === 0)) {
		console.log("CANNOT FIND .emended");
		return [];
	}

	// only deal with a single emendation list for now.
	let element = list[0];

	let items = element.querySelectorAll("li");
	// let items = element.querySelectorAll("li nobr[class^='mm']");
	let output = [];
	let ooo;
	let matches;
	let cn;
	let nobr;
	for (let i=0; i<items.length; i++) {
		ooo = {};
		measureStart = -1;
		measureStop  = -1;
		nobr = items[i].querySelector("nobr");
		if (!nobr) {
			console.log("NO NOBR FOUND IN ELEMENT", items[i]);
			continue;
		}
		cn = nobr.className;
		matches = cn.match(/\bmm(\d+)-(\d+)\b/);
		if (matches) {
			measureStart = matches[1];
			measureStop = matches[2];
		} else {
			matches = cn.match(/\bmm(\d+)\b/);
			if (!matches) {
				console.log("NO MEASURES FOUND IN NOBR CLASS", nobr);
				continue;
			}
			measureStart = matches[1];
		}
		if (measureStart < 0) {
			console.log("NO MEASURES FOUND IN ELEMENT", items[i]);
			continue;
		}
		ooo.measureStart = measureStart;
		ooo.measureStop = measureStop;
		let datatext = items[i].dataset.text;
		if (datatext) {
			ooo.text = window.decodeURIComponent(datatext);
		} else {
			ooo.text = items[i].textContent;
		}
		if (!ooo.text) {
			console.log("NO TEXT FOUND FOR EMENDATION", items[i]);
			continue;
		}

		output.push(ooo);
	}
	return output;
}



//////////////////////////////
//
// addFootnote -- Add a marker to verovio notation (created with --hum-type option from
//     Humdrum data) and a pop-up text message for a footnote attached to the marker.
//
// Arguments::
//	options == a list of options for controlling the footer display.
//      svg == an optional svg element for which to place the footnotes.
//
// The options argument parameters:
//	options.measureStart == the starting measure of the footnotes.  This is where
//                    the text marker will be added to the notation.
//      options.measureStop == the ending measure for the footnote.  Measures between
//                    the start and stop measure will be highlighted when the mouse
//                    is moved over the text marker for the footnote.
//      options.number == The index number of the emendation, starting at 0.
//      options.markText == The text to display in the notation to indicate a footnote exists.
//                    If undefined, then "*" will be the text marker.
//      options.color == The color of the text marker, and the highlighting color for the
//                    measure selection for the footnote.
//      options.text  == The text to display in the popup when mousing over the marker.
//      options.svgSelector == If the svg argument is undefined, then use the given
//                    selector to find the SVG image to process.  If both the svg argument
//                    and options.svgSelector are undefined, then the selector will be "svg".
//      options.placement == this can be "above" for above the system, and "below"
//                    for below the system (but "below" is not implemented yet).  Maybe
//                    also allow placing on a specific staff in the future, and perhaps
//                    at a given beat.
//      options.className == the HTML class to indicate a footnote (to control styling with
//                    CSS).  The default class is "footnote".
//

function addFootnote(options, svg) {
	// locate SVG image to apply footnote to:
	let svgselector = options.svgSelector;
	if (!svg) {
		if (!svgselector) {
			svg = document.querySelector("svg");
		} else {
			svg = document.querySelector(svgselector);
		}
	}
	if (!svg) {
		return;
	}

	// Prepare parameters from options:
	let measure = options.measureStart;
	if (measure < 0) {
		return;
	}
	let endmeasure = options.measureStop;
	let measureString = "" + measure;
	if (endmeasure > measure) {
		measureString += "-" + endmeasure;
	}
	let color = options.color;
	if (!color) {
		color = "darkorange";
	}
	let infotext = options.text;
	if (!infotext) {
		infotext = "";
	}
	let number = options.number || 0;
	let marktext = options.markText;
	if (!marktext) {
		marktext = "*";
	}
	let classname = options.className;
	if (!classname) {
		classname = "footnote";
	}
	let placement = options.placement;
	if (!placement) {
		placement = "above";
	}


	// Select the measure that the footnote will be attached to:
	let mclass = "m-" + measure;
	emeasure = svg.querySelector("." + mclass);
	if (!emeasure) {
		console.log("Cannot find measure", mclass);
		return;
	}

	// Get the bounding box to locate where the footnote will be placed:
	let bbox = emeasure.getBBox();
	let textx = bbox.x;
	let texty = bbox.y;
	if (placement === "below") {
		// Allow placing below measure in the future.
		// texty = texty + bbox.height;
	}

	let prev = emeasure.previousElementSibling;
	let etype = "";
	if (prev) {
		etype = prev.nodeName;
	}
	let textnode;
	let tspan;
	if (etype.match(/text/i)) {
		textnode = prev;
	} else {
		textnode = document.createElementNS("http://www.w3.org/2000/svg", "text");
		emeasure.parentNode.insertBefore(textnode, emeasure);
		textnode.setAttribute("class", classname);
		textnode.setAttribute("x", textx);
		textnode.setAttribute("y", texty);
		textnode.setAttribute("font-size", "500px");
		textnode.setAttribute("font-weight", "bold");
		textnode.style.cursor = "help";
	}

	// Add footer content in #footer area
	let footerdiv = document.createElement("DIV");
	footerdiv.style.position = "absolute";
	footerdiv.style.display = "none";
	footerdiv.classList.add("tooltip");
	footerdiv.dataset.contents = infotext;
	footerdiv.innerHTML = infotext;
	let footnotes = document.querySelector("#footnotes");
	if (footnotes) {
		footnotes.appendChild(footerdiv);
	}

	// Add a tspan in SVG with the infotext contents as a title:
	tspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
	tspan.setAttribute("onmouseenter", `highlightMeasure(event, ${number}, "${measureString}", "${color}")`);
	tspan.setAttribute("onmouseout", `unhighlightMeasure(event, ${number}, "${measureString}")`);
	tspan.style.fill = color;
	textnode.appendChild(tspan);
	let contents = document.createTextNode(marktext);
	tspan.appendChild(contents);
	// let etitle = document.createElementNS("http://www.w3.org/2000/svg", "title");
	// tspan.appendChild(etitle);
	// let titletext = document.createTextNode(infotext);
	// etitle.appendChild(titletext);
}



//////////////////////////////
//
// highlightMeasure --
//

function highlightMeasure(event, tooltipNumber, measure, color, suppress) {
	if (!color) {
		color = "darkorange";
	}

	if (!suppress) {
		showEmendationTooltip(event, tooltipNumber);
	}

	let matches;
	let startMeasure = -1;
	let endMeasure = -1;
	if (typeof measure === "string") {
		matches = measure.match(/(\d+)-(\d+)/);
		if (matches) {
			startMeasure = parseInt(matches[1]);
			endMeasure = parseInt(matches[2]);
		} else {
			matches = measure.match(/(\d+)/);
			if (matches) {
				startMeasure = parseInt(matches[1]);
			}
		}
	} else if (typeof measure === "number") {
		startMeasure = parseInt(measure);
	}
	if (startMeasure < 0) {
		console.log("Error: measure", measure, "is not valid");
		return;
	}

	if (endMeasure < startMeasure) {
		endMeasure = startMeasure;
	}

	let svg = document.querySelector("svg");
	if (!svg) {
		return;
	}

	let i;
	for (i=startMeasure; i<=endMeasure; i++) {
		let mclass = "m-" + i;
		emeasure = svg.querySelector("." + mclass);
		if (!emeasure) {
			continue;
		}
		if (color === "currentColor") {
			emeasure.style.fill = "";
			emeasure.style.stroke = "";
		} else {
			emeasure.style.fill = color;
			emeasure.style.stroke = color;
		}
		emeasure.setAttribute("color", color);
	}
}



//////////////////////////////
//
// unhighlightMeasure --
//

function unhighlightMeasure(event, emendationNumber, measure) {
	highlightMeasure(event, emendationNumber, measure, "currentColor", 1);
	hideEmendationTooltip(event, emendationNumber);
}

</script>


