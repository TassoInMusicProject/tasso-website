#!/usr/bin/perl
# vim: ts=3

use strict;

my $scoredir = "../../../tasso-scores";
my @files = glob("$scoredir/*/kern/*.krn");

my @rimefiles;
my @nonrimefiles;

for (my $i=0; $i<@files; $i++) {
	if ($files[$i] =~ /Trm\d{4}[a-z]+-/) {
		push(@rimefiles, $files[$i]);
	} else {
		push(@nonrimefiles, $files[$i]);
	}
}

my $width = 425;

print <<"EOT";
---
vim: ts=3
scripts-local: true
style-local: true
permalink: /analysis/melisma/index.html
---

<h1> Melisma analysis </h1>

This page extracts information about melimas in the music. By default
the following list is sorted by poem for comparison of melismas in
the same poem by different composers, but the order can be changed
to sort by the relative amount of melismas in each work, by composer,
or by publication date.  The "Score" entry lists the percentage of
notes in the music that are involved in a melisma.  Click on a link
in the "View" section to view the melismas highlighted in the score.
The different links are select the smallest melisma size that will
be highlighted.  For example, "4+ notes" will highlight notes when
there are at least four notes for a single syllable.  The "Words"
list contains a list of all of the words possessing more than one
note.  The color code: black=single note, purple=2 notes, blue=3
notes, green=4 notes, orange=5&ndash;10 notes, and red=11 or more
notes.

<style>
table.entry td.blank {
	width:40px;
}
table.entry td {
	vertical-align: top;
}
table.entry {
	margin-bottom: 50px;
}
.two {
	color: purple;
}
.three {
	color: dodgerblue;
}
.four {
	color: green;
}
.five {
	color: orange;
}
.ten {
	color: red;
}
div#form {
	margin-bottom: 25px;
}

</style>


<div id="form">
	Sort by:
	<select onchange="sortList(this.value)">
		<option value="poem">Poem</option>
		<option value="score">Melisma score</option>
		<option value="composer">Composer</option>
		<option value="date">Publication date</option>
	</select>
</div>

<div id="sort">

EOT

my $file;
foreach $file (@rimefiles) {
	processFile($file);
}

foreach $file (@nonrimefiles) {
	processFile($file);
}


print "</div>"; # end if id="sort"


###########################################################################



##############################
##
## processFile --
##

sub processFile {
	my ($file) = @_;
	open (FILE, $file) or die "Cannot read $file\n";
	my @contents = <FILE>;
	chomp @contents;
	close FILE;
	my $composer = "";
	my $title = "";
	my $final = "";
	my $publicationdate = "";
	my $rime = "";
	my $id = $file;
	$id =~ s/.*\///;
	$id =~ s/-.*//;
	my $score = getMelismaScore($id);
	foreach my $line (@contents) {
		if ($line =~ /^\!\!\!COM:\s*(.*)\s*/) {
			$composer = $1;
		}
		if ($line =~ /^\!\!\!OTL:\s*(.*)\s*/) {
			$title = $1;
		}
		if ($line =~ /^\!\!\!rime:\s*(.*)\s*/) {
			$rime = "(rime $1)";
		}
		if ($line =~ /^\!\!\!PDT:\s*(.*)\s*/) {
			$publicationdate = $1;
		}
		if ($line =~ /^\!\!\!final:\s*(.*)\s*/) {
			$final = $1;
		}
	}

	my $wordlist = getWordlist($id);

	my $base = $file;
	$base =~ s/.*\///;
	$base =~ s/\.krn$//;

	print << "EOT";

<div class="sortable">
<a name="$id"></a>
<table class="entry">

<tr>
	<td colspan="3" class="id">
		$id
	</td>
</tr>

<tr>
	<td class="blank">
	</td>
	<td>
		<b>Composer:</b>
	</td>
	<td class="composer">
		$composer / <span class="date">$publicationdate</span>
	</td>
</tr>

<tr>
	<td class="blank">
	</td>
	<td>
		<b>Title:</b>
	</td>
	<td>
		<i>$title</i> $rime
	</td>
</tr>

<tr>
	<td class="blank">
	</td>
	<td>
		<b>Score:</b>
	</td>
	<td class="score">
		$score of notes are in a melisma
	</td>
</tr>

<tr>
	<td class="blank">
	</td>
	<td>
		<b>View:</b>
	</td>
	<td>
		<a target="_blank" href="/work?id=$id&filter=melisma">2+ notes</a>,
		<a target="_blank" href="/work?id=$id&filter=melisma%20-m3">3+ notes</a>,
		<a target="_blank" href="/work?id=$id&filter=melisma%20-m4">4+ notes</a>,
		<a target="_blank" href="/work?id=$id&filter=melisma%20-m5">5+ notes</a>
	</td>
</tr>

<tr>
	<td class="blank">
	</td>
	<td>
		<b>Words:</b>
	</td>
	<td>
	$wordlist
	</td>
</tr>

</table>
</div>

EOT

}



##############################
##
## getWordlist --
##

sub getWordlist {
	my ($id) = @_;
	my $filename = "data/$id.aton";
	open (FILE, $filename) or return "ERROR";
	# open (FILE, $filename) or die "Cannot read data for $filename\n";
	my @contents = <FILE>;
	close FILE;
	chomp @contents;
	my $output;
	for (my $i=0; $i<@contents; $i++) {
		my $line = $contents[$i];
		next if $line !~ /^\@\@BEGIN:\s*WORD\s*$/;
		$output .= getWord($i, @contents);
	}
	$output =~ s/\,\s*$//;
	return $output;
}



##############################
##
## getMelismaScore --
##

sub getMelismaScore {
	my ($id) = @_;
	my $filename = "data/$id.aton";
	open (TFILE, $filename) or return "0%";
	my @contents = <TFILE>;
	close TFILE;
	chomp @contents;

	for (my $i=0; $i<@contents; $i++) {
		my $line = $contents[$i];
		chomp $line;
		if ($line =~ /^\@MELISMASCORE:\s*(.*)\s*$/) {
			return $1;
		}
	}

	return "0%";
}



##############################
##
## getWord --
##

sub getWord {
	my ($index, @contents) = @_;
	my %params;
	my $output = "";
	my $i;
	for ($i = $index+1; $i<@contents; $i++) {
		my $line = $contents[$i];
		last if $line =~ /^\@\@END:\s*WORD\s*$/;
		if ($line =~ /^\@([^ :]+):\s*(.*)\s*$/) {
			$params{$1} = $2;
		}
	}
	my @syllables = split(/\s+/, $params{"SYLLABLES"});
	my @notecounts = split(/\s+/, $params{"NOTECOUNTS"});
	for ($i=0; $i<@syllables; $i++) {
		my $count = $notecounts[$i];
		my $syllable = $syllables[$i];
		if ($count > 10) {
			$output .= "<span class='ten'>$syllable</span>";
			next;
		}
		if ($count == 1) {
			$output .= $syllable;
			next;
		}
		if ($count == 2) {
			$output .= "<span class='two'>$syllable</span>";
			next;
		}
		if ($count == 3) {
			$output .= "<span class='three'>$syllable</span>";
			next;
		}
		if ($count == 4) {
			$output .= "<span class='four'>$syllable</span>";
			next;
		}
		if ($count <= 10) {
			$output .= "<span class='five'>$syllable</span>";
		}
	}
	$output .= ", ";
	return $output;
}




