
<link rel="stylesheet" href="/styles/fonts/font-awesome/css/font-awesome.min.css">


<!--
	vim: ts=3
-->

<script src="/scripts/scripts-common.js"></script>
<script src="/scripts/scripts-worknav.js"></script>

{% include_relative scripts-pdf.html %}
{% include_relative templates.html %}
{% include_relative templates-report.html %}
{% include_relative listeners.html %}
{% include_relative footnote.html %}
{% include_relative tooltip.html %}


<script>
//
// Programmer:    Craig Stuart Sapp <craig@ccrma.stanford.edu>
// Creation Date: Thu Mar 31 21:34:11 PDT 2016
// Last Modified: Tue Mar 28 16:03:55 PDT 2017
// Filename:      work/scripts-local.html
// Syntax:        JavaScript 1.8/ECMAScript 5
// vim:           ts=3: ft=javascript
//
// Description:   JavaScript management for display of work pages.
//

let REPORT = {};
let SIGLALIST = {};
let SETTING = {};
let SEARCHFILTER = "";

let LAST_QUERY_MUSIC = {};
let LAST_QUERY_TEXT = {};
let TIMEMAP = {};
let QEVENTS = [];
let REFRESH = null;
let TRANSPOSE = "";
let DISPLAYCGISEARCH = false;
let ABBREVIATEDMATCHES = false;

let vrvToolkit;

let vrvOptions = {
	humType           : 1,
	adjustPageHeight  : 1,
	pageWidth         : 2500,
	pageHeight        : 1000,
	spacingNonLinear  : 0.55,
	/* spacingSystem     : 24, */
	spacingStaff      : 12,
	font              : "Leland",
	scale             : 40,
	pageMarginLeft    : 20,
	pageMarginRight   : 20,
	pageMarginTop     : 80,
	pageMarginBottom  : 80,
	justifyVertically : 0,
	footer            : "none",
	header            : "none",
	minLastJustification: 0.5,
	breaks            : "auto",
	lyricElision      : "narrow"
};

let CURRENT_PAGE = 1;
let INCIPIT_STYLE = 1;
let ORIGINAL_CLEFS = 0;
let MENSURAL = 0;
let INCLUDE_TEXT = 1;
let INCLUDE_ACCID = 1;
let CSS_TEXT = 1;
let PART_FILTER = 0;


//////////////////////////////
//
// setupVariables -- Used with CGI parameter k to set default style for
//   notation on page.
//

function setupVariables(string) {
	for (let i=0; i<string.length; i++) {
		let value = string.charAt(i);
		switch (value) {

			case 'a':
				INCLUDE_ACCID = !INCLUDE_ACCID;
				break;

			case 'e':
				INCIPIT_STYLE = !INCIPIT_STYLE;
				break;

			case 'o':
				ORIGINAL_CLEFS = !ORIGINAL_CLEFS;
				break;

			case 'm':
				MENSURAL = !MENSURAL;
				break;

			case 't':
				INCLUDE_TEXT = !INCLUDE_TEXT;
				break;

			case 'T':
				CSS_TEXT = !CSS_TEXT;
				break;

			case '1':
				PART_FILTER = 1;
				break;

			case '2':
				PART_FILTER = 2;
				break;

			case '3':
				PART_FILTER = 3;
				break;

			case '4':
				PART_FILTER = 4;
				break;

			case '5':
				PART_FILTER = 5;
				break;

			case '6':
				PART_FILTER = 6;
				break;

			case '7':
				PART_FILTER = 7;
				break;

			case '8':
				PART_FILTER = 8;
				break;

			case '9':
				PART_FILTER = 9;
				break;

			case '0':
				PART_FILTER = 0;
				break;

		}
	}

}



//////////////////////////////
//
// getTimemap --
//

function getTimemap(id) {
	if (!id) {
		id = ID;
	}
	if (TIMEMAP[id]) {
		return;
	}

	let request = new XMLHttpRequest();
	// let url = `{{site.tasso_data_url}}?a=timemap&f=${id}`;
	let url = `{{site.tasso_data_url_new}}/${id}-timemap.json`;
	request.open("GET", url);
	request.addEventListener("load", function() {
		TIMEMAP[id] = JSON.parse(this.responseText);
		interpolateIntegers(id);
	});
	request.send();
}



//////////////////////////////
//
// interpolateIntegers --
//

function interpolateIntegers(id) {
	timemap = TIMEMAP[id];
	if (timemap.length == 0) {
		return;
	}

	let newpoints = [];

	let byindex = {};

	for (let i=0; i<timemap.length; i++) {
		let qstamp = timemap[i].qstamp;
		byindex[qstamp] = {i: i, timemap: timemap[i]};
	}
	let maxval = timemap[timemap.length-1].qstamp;

	for (i=8; i<maxval; i+=8) {
		if (byindex[i]) {
			continue;
		}
		let newpoint;
		newpoint = interpolateTstamp(timemap, i);
		newpoints.push(newpoint);
		// console.log("MISSING: ", i, newpoint.tstamp);
	}

	TIMEMAP[id] = timemap.concat(newpoints);
}



//////////////////////////////
//
// interpolateTstamp --
//

function interpolateTstamp(timemap, qtime) {
	let i;
	let t1;
	let t2;
	let q1;
	let q2;
	for (i=0; i<timemap.length; i++) {
		if (timemap[i].qstamp < qtime) {
			continue;
		}
		if (i == 0) {
			console.log("STRANGE PROBLEM");
		}
		t1 = timemap[i-1].tstamp;
		t2 = timemap[i].tstamp;
		q1 = timemap[i-1].qstamp;
		q2 = timemap[i].qstamp;
		break;
	}

	if (!t2) {
			console.log("STRANGE PROBLEM 2");
	}

	let ttime = ((qtime-q1)/(q2-q1))*(t2-t1)+t1;

	let newpoint = { qstamp: qtime, tstamp: ttime};
	//console.log("NEWPOINT", newpoint);
	return newpoint;
}



//////////////////////////////
//
// continueSetup --
//

function continueSetup() {
	PrepareGlobalTassoObjects();
	if (ID) {
		displaySingleWork(ID)
	} else {
		displayWorkList();
	}
}



//////////////////////////////
//
// displayWorkList --
//

function displayWorkList(target) {
	if (!target) {
		target = "#contents";
	}
	let element = document.querySelector(target);
	if (!element) {
		console.warn("Could not find element", target);
		return;
	}
	let tsource = document.querySelector("#worklist-template").textContent;
	let workTemplate = Handlebars.compile(tsource);
	let output = workTemplate(WORKLIST[0]);

	element.innerHTML = output;
	fillInTimeKey();
	setTimeout(function () {
		document.body.classList.remove("waiting");
	}, 10);
}



//////////////////////////////
//
// fillInSyllableAnalysis --
//

function fillInSyllableAnalysis() {
	let element = document.querySelector("#syllable-analysis");
	if (!element) {
		console.warn("No #syllable-analysis element");
		return;
	}
	let filename = SETTING.SCOREDATA.DATAURL;
	let url = `https://verovio.humdrum.org/?file=${filename}&filter=textdur%20-amid&k=ey`;
	let text = `<li><a target="_blank" href="${url}">View syllable/duration analysis.</a></li>`;

	element.outerHTML = text;
}



//////////////////////////////
//
// fillInPlineAnalysis --
//

function fillInPlineAnalysis() {
	let element = document.querySelector("#pline-analysis");
	if (!element) {
		console.warn("No #pline-analysis element");
		return;
	}
	let helement = document.querySelector("#humdrum-data");
	if (!helement) {
		console.warn("No #humdrum-data element");
		return;
	}
	let humdrum = helement.textContent;
	if (!humdrum) {
		console.warn("Humdrum data is empty");
		return;
	}
	let matches = humdrum.match(/\\*pline:/);
	if (!matches) {
		return;
	}
	let filename = SETTING.SCOREDATA.DATAURL;
	let url = `https://verovio.humdrum.org/?file=${filename}&filter=pline%20-c&v=evenNoteSpacing&k=ey`;
	let text = `<li><a target="_blank" href="${url}">View poetic line markup in musical score.</a></li>`;
	
	element.outerHTML = text;
}



//////////////////////////////
//
// displaySingleWork --
//

function displaySingleWork(id, target) {
	if (!id) {
		id = ID;
	}
	ID = id;
	getTimemap(ID);
	QEVENTS = [];

	let element = document.querySelector("#contents");
	if (!element) {
		console.log("Error: no #contents");
		return;
	}

	if (!target) {
		target = "#contents";
	}
	SETTING = GetSettingEntry(id);
	// SETTING.ih = work.ih;
	if (SETTING.TITLE && SETTING.SETTINGTITLE) {
		let temp = SETTING.TITLE;
		SETTING.TITLE = SETTING.SETTINGTITLE;
		SETTING.TITLE += " <small>(<i>i.e.</i>, ";
		SETTING.TITLE += temp;
		SETTING.TITLE += ")</small>";
	} else if (!SETTING.TITLE) {
		if (SETTING.RIMETITLE && SETTING.SETTINGTITLE) {
			SETTING.TITLE = SETTING.SETTINGTITLE;
			if (SETTING.SOLERTI) {
				SETTING.TITLE += " <small>(<i>i.e.</i>, ";
				SETTING.TITLE += SETTING.RIMETITLE;
				SETTING.TITLE += ")</small>";
			}
		} else {
			SETTING.TITLE = SETTING.RIMETITLE;
		}
	}
	let tsource = document.querySelector("#singlework-template").textContent;
	let singleTemplate = Handlebars.compile(tsource);

	let output = singleTemplate(SETTING);
	document.title = ID + " workpage";
	element.innerHTML = output;
	let footnotes = document.createElement("DIV");
	footnotes.id = "footnotes";
	element.appendChild(footnotes);
	displayPartNumbers(id);
	CURRENT_PAGE = 1;
	displayIncipit(id);
	getHumdrum(id);
	getRange(id);
	getCriticalNotes(id);
	initializeSearchBoxes(CGI);
	fillInSyllableAnalysis();
	fillInPlineAnalysis();

	if (DISPLAYCGISEARCH) {
		setTimeout(function() {
			processMusicSearch();
			processTextSearch();
			DISPLAYCGISEARCH = false;
		}, 10);
	}
	setTimeout(function () {
		document.body.classList.remove("waiting");
	}, 10);
}



//////////////////////////////
//
// makeMusicQuery --
//

function makeMusicQuery(pitch, rhythm, interval) {
	if (pitch === null) { pitch = ""; }
	if (rhythm === null) { rhythm = ""; }
	if (interval === null) { interval = ""; }
	if (pitch && (!rhythm) && (!interval)) {
		return pitch;
	}
	if ((!pitch) && rhythm && (!interval)) {
		return rhythm;
	}
	if (pitch && rhythm && (!interval)) {
		return mergePitchAndRhythm(pitch, rhythm);
	}

	return "";
}


//////////////////////////////
//
// mergePitchAndRhythm --
//

function mergePitchAndRhythm(pitch, rhythm) {
	let pitches = [];
	let rhythms = [];
	let i;
	let current = "";
	let lastchar = "";
	let character = "";

	// build pitch list:
	for (i=0; i<pitch.length; i++) {
		character = pitch.charAt(i).toLowerCase();
		if (character === " ") {
			if (current) {
				pitches.push(current);
			}
			lastchar = character;
			current = "";
			continue;
		}
		if (character === ",") {
			if (current) {
				pitches.push(current);
			}
			lastchar = " ";
			current = "";
			continue;
		}
		if (character.match(/[a-g]/)) {
			if (lastchar.match(/[a-g]/)) {
				// a new note
				pitches.push(current);
				current = character;
			} else {
				// not a new note (there could be a rhythm or space before)
				current += character;
			}
			lastchar = character;
			continue;
		}
		if (character.match(/[0-9]/)) {
			if (lastchar.match(/[a-g]/)) {
				// a new note
				pitches.push(current);
				current = character;
			} else {
				// not a new note (there could be a rhythm or space before)
				current += character;
			}
			lastchar = character;
			continue;
		}
		if (character === ".") {
			// rhythm augmentation dot, but most come after a rhythm
			if (current.match(/\d$/)) {
				current += character;
			} else {
				// strange problem, so ignore
			}
			lastchar = character;
			continue;
		}
	}
	if (current) {
		pitches.push(current);
		current = "";
	}

	// treat each digit as a separate rhythm
	rhythm = rhythm.replace(/\b16\b/g, "6"); // 16 -> 6 for now
	rhythm = rhythm.replace(/\b32\b/g, "3"); // 32 -> 3 for now
	
	lastchar = "";
	character = "";
	let newrhythm = "";
	for (i=0; i<rhythm.length; i++) {
		character = rhythm.charAt(i);
		if ((lastchar === ".") || lastchar.match(/\d/)) {
			if (character.match(/\d/)) {
				newrhythm += ",";
			}
		}
		newrhythm += character;
		lastchar = character;
	}
	rhythm = newrhythm;

	current = "";
	lastchar = "";
	character = "";
	// Build rhythm list.
	for (i=0; i<rhythm.length; i++) {
		character = rhythm.charAt(i).toLowerCase();
		if (character === " ") {
			if (current) {
				rhythms.push(current);
			}
			lastchar = character;
			current = "";
			continue;
		}
		if (character === ",") {
			if (current) {
				rhythms.push(current);
			}
			lastchar = " ";
			current = "";
			continue;
		}
		if (character.match(/[a-g]/)) {
			if (lastchar.match(/[a-g]/)) {
				// a new note
				rhythms.push(current);
				current = character;
			} else {
				// not a new note (there could be a rhythm or space before)
				current += character;
			}
			lastchar = character;
			continue;
		}
		if (character.match(/[0-9]/)) {
			if (lastchar.match(/[a-g]/)) {
				// a new note
				rhythms.push(current);
				current = character;
			} else {
				// not a new note (there could be a rhythm or space before)
				current += character;
			}
			lastchar = character;
			continue;
		}
		if (character === ".") {
			// rhythm augmentation dot, but most come after a rhythm
			if (current.match(/\d$/)) {
				current += character;
			} else {
				// strange problem, so ignore
			}
			lastchar = character;
			continue;
		}
	}

	let maxlen = pitches.length;
	if (rhythms.length > maxlen) {
		maxlen = rhythms.length;
	}
	let output = "";
	for (i=0; i<maxlen; i++) {
		if (i < rhythms.length) {
			output += rhythms[i];
		}
		if (i < pitches.length) {
			output += pitches[i];
		} else {
			output += " ";
		}
	}
	return output;
}


///////////////////////////////
//
// displayPartNumbers --
//

function displayPartNumbers(id) {
	let element = document.querySelector("#voice-buttons");
	if (!element) {
		return;
	}
	if (!SETTING) {
		return;
	}
	if (!SETTING.SCOREDATA) {
		return;
	}
	let vcount = 0;
	// let works = WORKLIST[0].works;
	let vabbr = SETTING.SCOREDATA.VABBR;
	if (!vabbr) {
		return;
	}

	// remove alternate abbreviation names:
	for (let i=0; i<vabbr.length; i++) {
		let newvabbr = vabbr[i].replace(/\([^)]*\)/g, "").replace(/\s*$/, "");
		if (newvabbr) {
			vabbr[i] = newvabbr;
		}
	}

	vcount = vabbr.length;
	let output = ""
	//let numlist = [
	//	"&#x2780;",
	//	"&#x2781;",
	//	"&#x2782;",
	//	"&#x2783;",
	//	"&#x2784;",
	//	"&#x2785;",
	//	"&#x2786;",
	//	"&#x2787;",
	//	"&#x2788;"
	//];
	let i;
	output += "<div style='font-size:1.5em;'>";
	output += "<nobr>";
	for (i=0; i<vcount; i++) {
		let aaa = vabbr[i].replace(/[[]/g, "").replace(/\]/g, "");

		output += "<span ";
		output += "title='show only part " + (i+1) + " (" + (i+1) + ")"  + "' id='part" + (i+1);
		output += "' class='voice-icon'"
		output += " onclick='showPart(\"" + (i+1) + "\");'";
		output += ">";
		output += "<span class='fa-stack fa-3x'>";
		output += "<i class='fa fa-circle fa-stack-2x'></i>";
		output += "<strong class='fa-stack-1x text-primary'>";
		output += aaa;
		output += "</strong>";
		output += "</span>";
		output += "</span>";

	}
	output += "</nobr>";
	output += "</div>";
	
	element.innerHTML = output;

}



///////////////////////////////
//
// showPart --
//

function showPart(partnum) {
	if (partnum == PART_FILTER) {
		partnum = 0;
		PART_FILTER = 0;
	} else {
		PART_FILTER = partnum;
	}
	initializeVerovioNotation();
}



//////////////////////////////
//
// highlightPartIcon --
//

function highlightPartIcon(partnum) {
	let elements = document.querySelectorAll(".voice-icon");
	let number;
	for (let i=0; i<elements.length; i++) {
		let id = elements[i].id;
		let num = id.match(/(\d+)$/)[1];
		if (num == partnum) {
			elements[i].className += " highlight";
			elements[i].title = "show all parts (0)";
		} else {
			elements[i].classList.remove("highlight");
			elements[i].title = "show only part " + num + " (" + num + ")";
		}
	}
}



///////////////////////////////
//
// displayIncipit -- Display incipit as a place holder before the verovio 
//     toolkit generates its own display.
//

function displayIncipit(id) {
return; // disable for now
	if (!localStorage["svg_" + id]) {
		return;
	}

	let element = document.querySelector("#verovio-display");
	element.style.height = "200px";
	if (!element) {
		return;
	}

	element.innerHTML = localStorage["svg_" + id];
}



////////////////////////////////
//
// emptyReportButton --
//

function emptyReportButton()  {
	let url = "https://github.com/TassoInMusicProject/tasso-website";
	url += "/blob/gh-pages/data/reports/";

	let output = "<div style='display:none; floating:none;' class='expert'>";
	output += "<a target='_blank' class='eebutton' href='";
	output += url;
	output += "'>Add critical report</a>";
	output += "</div>";

	return output;
}



///////////////////////////////
//
// getCriticalNotes --
//

function getCriticalNotes(id) {
	let tag = "report_" + id;
	let tagcontent;
	let element = document.querySelector("#" + tag);
	if (!element) {
		console.log("CANNOT FIND ELEMENT " + tag);
		return;
	}
	element.innerHTML = emptyReportButton();

//	if (REPORT[id]) {
//		if (element) {
//			output += REPORT[id];
//			element.innerHTML = addCatalogLinks(output);
//		}
//	} else {
		let url = "{{site.critical_reports}}/" + id + "-report.aton";
		let request = new XMLHttpRequest();
		request.open('GET', url);
		request.addEventListener("load", function() {
			if (this.status == 200) {
				let aton = new ATON;
				let raw = this.responseText
						.replace(/---/g, "&mdash;")
						.replace(/--/g, "&ndash;");
				let data = aton.parse(raw).REPORT;
				SETTING.REPORT = data;

				let tsource = document.querySelector("#criticalreport-template").textContent;
				let template = Handlebars.compile(tsource);
				let result = template(data);

				REPORT[id] = result;
				if (element) {
					// element.innerHTML = addCatalogLinks(data);
					// catalog links now done differently:
					element.innerHTML = result;
				}
				fillInDedicatee(id);
				fillInOtherSources(id);
				fillInPrimarySources(id);

				fillInPoemText(SETTING);
			}
		});
		request.send()
//	}

//	getCriticalReportNoRecurse(ORDER[id].next);
//	getCriticalReportNoRecurse(ORDER[id].previous);
}


//////////////////////////////
//
// fillInPoemText --
//

function fillInPoemText(setting) {
	let element = document.querySelector("#poem-text");
	if (!element) {
		console.warning("Warning: Cannot find #poem-text");
		return;
	}


	setting.VERSE = setting.MVERSE;
	if (typeof setting.VERSE === "string") {
		setting.VERSE = [ setting.VERSE ];
	}
	if (typeof setting.TVERSE  === "string") {
		setting.TVERSE = [ setting.TVERSE ];
	}

	// Remove MVERSE markup and use in VERSE field:
	for (let i=0; i<setting.VERSE.length; i++) {
		setting.VERSE[i] = setting.VERSE[i].replace(/-/g, "");
		setting.VERSE[i] = setting.VERSE[i].replace(/\+/g, "");
		setting.VERSE[i] = setting.VERSE[i].replace(/_/g, " ");
		setting.VERSE[i] = setting.VERSE[i].replace(/=.*/g, "");
	}

	console.warn("SETTING", setting);
	console.warn("VERSE", setting.VERSE);
	console.warn("MVERSE", setting.MVERSE);
	console.warn("TVERSE", setting.TVERSE);

	let tsource = document.querySelector("#poem-template").textContent;
console.warn("TSOURCE", tsource);
	let template = Handlebars.compile(tsource);
	let result = template(setting);

	element.innerHTML = result;

}


//////////////////////////////
//
// addCatalogLinks --
//

function addCatalogLinks(text) {
	let re = /(Trm\d\d\d\d[a-z]+)/g;
	return text.replace(re, function(match, id) {
		if (id) {
			return "<a href='/work?id=" + id + "'>" + id + "</a>";
		}
	});
}



//////////////////////////////
//
// getCriticalReportNoRecurse --
//

function getCriticalReportNoRecurse(id) {
	let tag = "report_" + id;
	if (REPORT[id]) {
		return;
	}

	let url = "/include/report/" + id + "-report.aton";
	let request = new XMLHttpRequest();
	request.open('GET', url);
	request.addEventListener("load", function() {
		if (this.status == 200) {
			let data = this.responseText;
			REPORT[id] = data;
		}
	});
	request.send()
}



//////////////////////////////
//
// getHumdrumKernCount --
//

function getHumdrumKernCount(humid) {
	let sourceid = humid ? humid : "humdrum-data";
	let source = document.querySelector("#" + sourceid);
	if (!source) {
		console.log("Cannot find source id:", sourceid);
		return;
	}
	let content = source.textContent;
	let matches;

	let kcount = 0;
	let tcount = 0;
	if (matches = content.match(/^(\*\*.*)/m)) {
		let tokens = matches[1].split("\t");
		for (let i=0; i<tokens.length; i++) {
			if (tokens[i] === "**kern") {
				kcount++;
			} else if (tokens[i] === "**text") {
				tcount++;
			}
		}
	}

	return [kcount, tcount];
}


///////////////////////////////
//
// generateVerovioFilters --
//

function generateVerovioFilters(targetid, musicquery, textquery) {
	let output = [];

	// Get the number of **kern and **text spines for dealing
	// with part extraction.
	let kcount = 0;
	let tcount = 0;
	let content;
	[kcount, tcount] = getHumdrumKernCount(targetid);
	//console.log("KernCount", kcount, "TextCount", tcount);

	let eanalysis = document.querySelector("#analysis-select");
	if (eanalysis) {
		let analysisValue = eanalysis.value;
		if (analysisValue && !analysisValue.match(/^\s*$/)) {
			output.push(analysisValue)
		}
	}

	if (PART_FILTER) {
		let kval = kcount - PART_FILTER + 1;
		if (kval > 0) {
			output.push("extract -k " + kval);
			kcount = 1;
			tcount = 1;
		}
	}

	if (MENSURAL) {
		output.push("kern2mens");
	}

	if (ORIGINAL_CLEFS) {
		output.push("modori -o");
		// previous method was to use x-path, which is now disabled in the converter:
		// vrvOptions.appXPathQuery = ["./rdg[contains(@label, 'original-clef')]"];
	} else {
		// vrvOptions.appXPathQuery = ["./rdg[contains(@label, 'asdfghjkl')]"];
	}

	if (!INCLUDE_TEXT) {
		output.push("extract -I **text");
		output.push("autobeam");
	}
	if (!INCLUDE_ACCID) {
		if (MENSURAL) {
			output.push("shed -ke 's/z/y/g'");
		} else {
			output.push("shed -ke 's/i/y/g'");
		}
	}

	if (!musicquery) {
		musicquery = LAST_QUERY_MUSIC;
	}
	if (!textquery) {
		textquery = LAST_QUERY_TEXT;
	}

	let musicsearch = createMusicSearchFilter(musicquery);
	SEARCHFILTER = musicsearch;

	let textsearch = createTextSearchFilter(textquery);

	// Add music search filter:
	if (!musicsearch.match(/^\s*$/)) {
		output.push(musicsearch);
	}

	// Add text search filter:
	if (!textsearch.match(/^\s*$/)) {
		output.push(textsearch);
	}

	// Add URL parameter filter (for analysis usually):
	if (CGI.filter) {
		output.push(CGI.filter);
	}

	// Add transposition:
	if (TRANSPOSE) {
		output.push("transpose -t " + TRANSPOSE);
	}

	return output;
}



//////////////////////////////
//
// initializeVerovioNotation --
//

function initializeVerovioNotation(targetid, musicquery, textquery) {
	if (!targetid) {
		targetid = "humdrum-data";
	}

	highlightPartIcon(PART_FILTER);
	displayTextState();
	displayMensuralState();
	displayMensurationState();
	displayAccidState();

	// Get the number of **kern and **text spines for dealing
	// with part extraction.
	let kcount = 0;
	let tcount = 0;
	let content;
	[kcount, tcount] = getHumdrumKernCount(targetid);
	//console.log("KernCount", kcount, "TextCount", tcount);

	if (!kcount) {
		return;
	}

	// If filters is empty, it will be deleted later.
	// vrvOptions.filter = [];
	vrvOptions.filter = generateVerovioFilters(targetid, musicquery, textquery);

	vrvOptions.pageHeight = 1000;

	if (!INCLUDE_TEXT) {
		vrvOptions.spacingStaff = 12;
	} else {
		vrvOptions.spacingStaff = 9;
	}

	if (kcount > 0) {
		vrvOptions.pageHeight = 230 * kcount + 80 * tcount;
		// target.style.height = parseInt(vrvOptions.pageHeight / 3.8 + 100 ) + "px";
	}

	if (INCIPIT_STYLE) {
		// full-page display
		vrvOptions.pageHeight = 60000;
	}
	showIncipitState();

	// add header footer information to data

	if (vrvOptions.filter.length == 0) {
		// delete vrvOptions.filter;
		// The filter has to exist and be empty in order for
		// an old filter to be flushed from some cache.
		// Deleting an empty filter will not do that.
		vrvOptions.filter = "";
	} else if (vrvOptions.filter.length == 1) {
		vrvOptions.filter = vrvOptions.filter[0];
	}

	vrvOptions.postFunction = notationCallback;
	vrvOptions.source = targetid;

	console.log("Verovio Options", vrvOptions);
	displayHumdrum(vrvOptions);


	/*
	vrvToolkit.setOptions(vrvOptions);
	vrvToolkit.loadData(content);
	let pagecount = vrvToolkit.getPageCount();
	if (CURRENT_PAGE > 1) {
		if (CURRENT_PAGE > pagecount) {
			CURRENT_PAGE = 1;
		}
	} else if (CURRENT_PAGE < 1) {
		CURRENT_PAGE = pagecount;
	}
	let svg = vrvToolkit.renderToSVG(CURRENT_PAGE);
	let matches;
	if (matches = svg.match(/height="(\d+)px"/)) {
		target.style.height = "";
	}
	target.innerHTML = svg;
	*/
}


//////////////////////////////
//
// createMusicSearchFilter --
//

function createMusicSearchFilter(query) {
	if (!query) {
		return "";
	}
	let marg = "";
	if (query.query)    { marg += " -q '" + query.query    + "'"; }
	if (query.pitch)    { marg += " -p '" + query.pitch    + "'"; }
	if (query.interval) { marg += " -i '" + query.interval + "'"; }
	if (query.rhythm)   { marg += " -r '" + query.rhythm   + "'"; }
	let output = ""
	if (!marg.match(/^\s*$/)) {
		output = "msearch" + marg + " -c orange";
	}
	return output;
}



//////////////////////////////
//
// createTextSearchFilter --
//

function createTextSearchFilter(query) {
	if (!query) {
		return "";
	}
	let targ = "";
	if (query.text) {
		targ += " -t '" + query.text + "'";
	}
	let output = ""
	if (!targ.match(/^\s*$/)) {
		output += "msearch" + targ + " -c hotpink";
	}
	return output;
}



//////////////////////////////
//
// notationCallback --
//

function notationCallback(id) {
	prepareQEvents(id);
	prepareLyricSpaces(id);
	processCssTextState();
	processMatches();
	addFootnotes(id);
}
	

//////////////////////////////
//
// processMatches --
//

function processMatches() {
	if (SEARCHFILTER) {
		// extract the filtered Humdrum data from verovio, and
		// pull out the match count from the data and report
		// search toolbar
		vrvWorker.getHumdrum()
		.then(function(humdrumdata) {
			let data = humdrumdata.match(/[^\r\n]+/g);
			let count = -1;
			let matches;
			for (let i=data.length - 1; i > 0; i--) {
				matches = data[i].match(/^!!@MATCHES:\s*(\d+)/);
				if (matches) {
					count = parseInt(matches[1]);
					break;
				}
			}
			let eresults = document.querySelector("#search-results");
			let eanalysis = document.querySelector("#analysis-div");
			if (eresults) {
				let output = "";
				if (count < 0) {
					eresults.style.visibility = "hidden";
					eanalysis.style.visibility = "visible";
					output = "0 matches";
				} else if (count == 0) {
					eresults.style.visibility = "visible";
					eanalysis.style.visibility = "hidden";
					output = "0 matches";
				} else if (count == 1) {
					eresults.style.visibility = "visible";
					eanalysis.style.visibility = "hidden";
					output = "1 match";
				} else {
					eresults.style.visibility = "visible";
					eanalysis.style.visibility = "hidden";
					output = count + " matches";
				}
				eresults.innerHTML = output;
				// showSearchLinkIcon();
			}
		});
	} else {
		let eresults = document.querySelector("#search-results");
		let eanalysis = document.querySelector("#analysis-div");
		if (eresults) {
			eresults.style.visibility = "hidden";
			eanalysis.style.visibility = "visible";
		}
	}
}


//////////////////////////////
//
// prepareQEvents --
//

function prepareQEvents(target) {
	if (typeof target === "string") {
		target = document.querySelector("svg");
	}

	let svgnotes = target.querySelectorAll("g[id^='note-']");
	let qpre = {};
	let matches;
	let ques;
	let obj;
	for (let i=0; i<svgnotes.length; i++) {

		if (matches = svgnotes[i].className.baseVal.match(/qon-([^\s]+)/)) {
			ques = getQstampFloat(matches[1]);
			if (!qpre[ques]) {
				qpre[ques] = {qstamp: ques, on:[], off:[]};
			}
			qpre[ques].on.push(svgnotes[i]);
		}

		if (matches = svgnotes[i].className.baseVal.match(/qoff-([^\s]+)/)) {
			ques = getQstampFloat(matches[1]);
			if (!qpre[ques]) {
				qpre[ques] = {qstamp: ques, on:[], off:[]};
			}
			qpre[ques].off.push(svgnotes[i]);
		}

	}
	QEVENTS = [];
	for (let qst in qpre) {
		QEVENTS.push(qpre[qst])
	}
	QEVENTS.sort(function(a, b) {
		return a.qstamp - b.qstamp;
	});
}



//////////////////////////////
//
// prepareLyricSpaces --
//

function prepareLyricSpaces(target) {
	return; // deactivate for now since text can have nested tspans now.
	// add spaces after ends of words (for copy/paste from SVG):
	let ends = target.querySelectorAll("svg g.syl.t text tspan")
	for (i=0; i<ends.length; i++) {
    	let text = ends[i].textContent;
     	ends[i].textContent = text + " ";
	}
}



//////////////////////////////
//
// getQstampFloat --
//

function getQstampFloat(str) {
	let ques = -1;
	if (str.match(/d/)) {
		ques = parseFloat(str.replace(/d/, "."));
	} else if (str.match(/_/)) {
		let matches = str.match(/(\d+)_(\d+)/);
		if (matches) {
			ques = parseInt(matches[1]) / parseInt(matches[2]);
		}
	} else if (str.match(/^\d+$/)) {
		ques = parseInt(str);
	}
	return ques;
}



//////////////////////////////
//
// incrementVerovioPage --
//

function incrementVerovioPage(direction) {
	CURRENT_PAGE += direction;
	let pagecount = vrvToolkit.getPageCount();
	if (CURRENT_PAGE > 1) {
		if (CURRENT_PAGE > pagecount) {
			CURRENT_PAGE = 1;
		}
	} else if (CURRENT_PAGE < 1) {
		CURRENT_PAGE = pagecount;
	}

	let target = document.querySelector("#verovio-display");
	if (!target) {
		console.log("Cannot find target id: #verovio-display");
		return;
	}

	let svg = vrvToolkit.renderToSVG(CURRENT_PAGE, vrvOptions);
	target.innerHTML = svg;

	prepareQEvents(target);
	prepareLyricSpaces(target);
}



//////////////////////////////
//
// firstVerovioPage --
//

function firstVerovioPage(direction) {
	CURRENT_PAGE = 1;
	let pagecount = vrvToolkit.getPageCount();
	if (CURRENT_PAGE > 1) {
		if (CURRENT_PAGE > pagecount) {
			CURRENT_PAGE = 1;
		}
	} else if (CURRENT_PAGE < 1) {
		CURRENT_PAGE = pagecount;
	}

	let target = document.querySelector("#verovio-display");
	if (!target) {
		console.log("Cannot find target id: #verovio-display");
		return;
	}

	let svg = vrvToolkit.renderToSVG(CURRENT_PAGE, vrvOptions);
	target.innerHTML = svg;

	prepareQEvents(target);
	prepareLyricSpaces(target);
}



//////////////////////////////
//
// lastVerovioPage --
//

function lastVerovioPage(direction) {
	CURRENT_PAGE = -1;
	let pagecount = vrvToolkit.getPageCount();
	if (CURRENT_PAGE > 1) {
		if (CURRENT_PAGE > pagecount) {
			CURRENT_PAGE = 1;
		}
	} else if (CURRENT_PAGE < 1) {
		CURRENT_PAGE = pagecount;
	}

	let target = document.querySelector("#verovio-display");
	if (!target) {
		console.log("Cannot find target id: #verovio-display");
		return;
	}

	let svg = vrvToolkit.renderToSVG(CURRENT_PAGE, vrvOptions);
	target.innerHTML = svg;

	prepareQEvents(target);
	prepareLyricSpaces(target);
}




//////////////////////////////
//
// getHumdrum --
//

function getHumdrum(id) {
	let tag = "humdrum_" + id;
	let tagcontent;
	let element = document.querySelector("#humdrum-data");
	if (!element) {
		return;
	}

	let text = "";
	let postdata = "";
	postdata += "\n!!!footer-right: \\n\\n\\n%P";
	postdata += "\n!!!footer-center: \\n\\n\\n@{SCA}, @{EEV}";
	postdata += "\n!!!footer-left: \\n\\n\\n@{YEC}";
	postdata += "\n!!!header-left: @{EED:n}, ed.";

	if (sessionStorage[tag]) {
		let scoreelements = document.querySelectorAll(".musical-content");
		for (let i=0; i<scoreelements.length; i++) {
			scoreelements[i].style.display = "block";
		}
		text = sessionStorage[tag];
		if (!text.match(/footer-center/)) {
			text += postdata;
		}
		element.textContent = text;
		initializeVerovioNotation("humdrum-data");
	} else if (SETTING.SCOREDATA && SETTING.SCOREDATA.DATAURL) {
		let action = "humdrum";
		let url = SETTING.SCOREDATA.DATAURL;
		// old url from CCARH server:
		// let url = "{{site.tasso_data_url}}/?a=" + action + "&id=" + id;
		let request = new XMLHttpRequest();
		request.open('GET', url);
		request.addEventListener("load", function() {
			let ses = document.querySelectorAll(".musical-content");
			for (let ii=0; ii<ses.length; ii++) {
				ses[ii].style.display = "block";
			}
			let data = this.responseText;
			if (!data.match(/footer-center/)) {
				data += postdata;
			}
			sessionStorage[tag] = data;
			if (element) {
				element.textContent = data;
				initializeVerovioNotation("humdrum-data");
			}
		});
		request.send()
	}

	// ggg getHumdrumNoRecurse(ORDER[id].next);
	// ggg getHumdrumNoRecurse(ORDER[id].previous);
}



//////////////////////////////
//
// getHumdrumNoRecurse --
//

function getHumdrumNoRecurse(id) {
	let tag = "humdrum_" + id;
	if (sessionStorage[tag]) {
		return;
	}

	let action = "humdrum";
	// let url = "{{site.tasso_data_url}}/?a=" + action + "&id=" + id
	let url = `{{site.tasso_data_url_new}}/${id}.krn`;
	let request = new XMLHttpRequest();
	request.open('GET', url);
	request.addEventListener("load", function() {
		let data = this.responseText;
		sessionStorage[tag] = data;
	});
	request.send()
}



//////////////////////////////
//
// getRange -- Get and display note attack pitch range, such as
//    https://Trm0047m-prange-attack.svg
//    Store on page inside element "#range".
//

function getRange(id) {
	let url = `https://data.tassomusic.org/${id}-prange-attack.svg`;
	if (sessionStorage[url]) {
		displayRange("#range", sessionStorage[url]);
		return;
	}

	fetch(url)
		.then(response => {
			if (!response.ok) {
				throw new Error("Network response was not ok");
			}
			return response.text();
		})
		.then(svg => {
			if (svg.match(/no image found for/)) {
				console.error("Bad SVG content:", svg);
				return;
			}
			sessionStorage[url] = svg;
			displayRange("#range", svg);
		})
		.catch(error => {
			console.error("There was a problem with fetching:", error);
		})
}



//////////////////////////////
//
// displayRange -- Once an SVG of the range has been downloaded,
//     display the SVG range plot on the work page.
//

function displayRange(selector, svg) {
	let element = document.querySelector("#range");
	if (!element) {
		console.error("ERROR: No element #range");
		return;
	}
	let output = "";
	output += "<h4 style='margin-left:30px' id='vocal_ranges'>VOCAL RANGES</h4>";
	output += "<div class='indent'>";
	output += svg;
	output += "</div>";
	element.innerHTML = output;
	setSvgSize();
}



//////////////////////////////
//
// setSvgSize --
//

function setSvgSize() {
	let svg = document.querySelector("#range svg");
	if (!svg) {
		// no range, so give up
		return;
	}
	let width = svg.getAttribute("width");
	let height = svg.getAttribute("height");
	let scale = 1.6;
	width *= scale;
	height *= scale;
	svg.setAttribute("width", width);
	svg.setAttribute("height", height);
}



//////////////////////////////
//
// getRangeNoRecurse --
//

function getRangeNoRecurse(id) {
	let tag = "range_" + id;
	if (sessionStorage[tag]) {
		return;
	}

	// let action = "prange-svg";
	// let url = "{{site.tasso_data_url}}/?a=" + action + "&id=" + id
	let url = `{{site.tasso_data_url_new}}/${id}-prange-attack.svg`;
	let request = new XMLHttpRequest();
	request.open('GET', url);
	request.addEventListener("load", function() {
		let data = this.responseText;
		sessionStorage[tag] = data;
	});
	request.send()
}



/*
//////////////////////////////
//
// getWorkInfo --
//

function getWorkInfo(id) {
	if (!WORKLIST) {
		return null;
	}
	let i, j;
	for (i=0; i<WORKLIST.length; i++) {
		let rep = WORKLIST[i];
		for (j=0; j<rep.works.length; j++) {
			if (rep.works[j].id === id) {
				return rep.works[j];
			}
		}
	}
}
*/



//////////////////////////////
//
// getNextWork --
//

function getNextWork(id) {
	return id;
}



//////////////////////////////
//
// getPreviousWork --
//

function getPreviousWork(id) {
	return id;
}



//////////////////////////////
//
// sortByText --
//

function sortByText(index, selector) {
	let data = document.querySelectorAll(".data");
	let datalist = [];
	let i;
	for (i=0; i<data.length; i++) {
		datalist.push(data[i]);
	}
	datalist.sort(function(a, b) {
		let A;
		let B;
		if (selector) {
			A = a.cells[index].querySelector(selector).innerHTML;
			B = b.cells[index].querySelector(selector).innerHTML;
		} else {
			A = a.cells[index].innerHTML;
			B = b.cells[index].innerHTML;
		}
		let result = A.localeCompare(B);
		return result;
	});
	let body = document.querySelector("table.worklist tbody");
	body.innerHTML = "";
	for (i=0; i<datalist.length; i++) {
		body.appendChild(datalist[i]);
	}
}



//////////////////////////////
//
// sortByNumber --
//

function sortByNumber(index) {
	let data = document.querySelectorAll(".data");
	let datalist = [];
	let i;
	for (i=0; i<data.length; i++) {
		datalist.push(data[i]);
	}
	datalist.sort(function(a, b) {
		let A = parseInt(a.cells[index].innerHTML);
		let B = parseInt(b.cells[index].innerHTML);
		if (A < B)      { return -1 }
		else if (A > B) { return +1 }
		else            { return 0  }
	});
	let body = document.querySelector("table.worklist tbody");
	body.innerHTML = "";
	for (i=0; i<datalist.length; i++) {
		body.appendChild(datalist[i]);
	}
}



//////////////////////////////
//
// ExpandIncipit --
//

function ExpandIncipit() {
	if (INCIPIT_STYLE) {
		// already expanded
		return;
	}
	let element = document.querySelector("#expand");
	let text = element.textContent;
	INCIPIT_STYLE = 1;
	showIncipitState();
	initializeVerovioNotation();
}



//////////////////////////////
//
// toggleIncipit --
//

function toggleIncipit() {
	let element = document.querySelector("#expand");
	let text = element.textContent;
	INCIPIT_STYLE = !INCIPIT_STYLE;
	showIncipitState();
	initializeVerovioNotation();
}



//////////////////////////////
//
// showIncipitState --
//

function showIncipitState() {
	let element = document.querySelector("#expand");
	let nelement = document.querySelector("#nextsys");
	let pelement = document.querySelector("#prevsys");
	let felement = document.querySelector("#firstsys");
	let lelement = document.querySelector("#lastsys");
	if (INCIPIT_STYLE) {
		// element.textContent = "contract";
		element.innerHTML = '<div title="collapse to incipit (e)" class="fa fa-compress" aria-hidden="true"></div>';
		nelement.textContent = "";
		pelement.textContent = "";
		lelement.textContent = "";
		felement.textContent = "";
	} else {
		//element.textContent = "expand";
		element.innerHTML = '<div title="expand to complete score (e)" class="fa fa-expand" aria-hidden="true"></div>';
		pelement.innerHTML = '<i class="fa fa-arrow-left" aria-hidden="true"></i>';
		nelement.innerHTML = '<i class="fa fa-arrow-right" aria-hidden="true"></i>';
		lelement.innerHTML = '<i class="fa fa-step-forward" aria-hidden="true"></i>';
		felement.innerHTML = '<i class="fa fa-step-backward" aria-hidden="true"></i>';
	}
}



//////////////////////////////
//
// displayNextWork --
//
//

function displayNextWork(id) {
	if (!id) {
		id = ID;
	}
	let newid = ORDER[id].next;
	ID = newid;
	displaySingleWork(ID);
}



//////////////////////////////
//
// displayPreviousWork --
//
//

function displayPreviousWork(id) {
	if (!id) {
		id = ID;
	}
	let newid = ORDER[id].previous;
	ID = newid;
	displaySingleWork(ID);
}



//////////////////////////////
//
// downloadMeiData --
//

function downloadMeiData(event) {
	vrvWorker.getMEI()
	.then(function(data) {
		data = data.replace(/\btype=".*?"/g, "");
		saveMei(data, "ID.mei");
	});
}


//////////////////////////////
//
// saveMei --
//

function saveMei(data, filename) {
	let link = document.createElement("a");
	link.href = "data:text/octet-stream;base64," + btoa(unescape(encodeURIComponent(data)));
	let setting = RSETTINGS[ID];
	if (setting) {
		let scoredata = setting.SCOREDATA;
		if (scoredata) {
			let dataurl = scoredata.DATAURL.replace(/.*\//, "").replace(/\.krn/, ".mei");
			link.download = dataurl;
		} else {
			link.download = filename;
		}
	} else {
		link.download = filename;
	}
	document.body.appendChild(link);
	link.click();
	document.body.removeChild(link);
	if (event) {
		event.preventDefault();
	}
}



//////////////////////////////
//
// showMeiData --
//

function showMeiData(event) {
	let data = vrvToolkit.getMEI(0, 1);
	let prefix = "<textarea style='spellcheck=false; width:100%; height:100%;'>";
	let postfix = "</textarea>";
	let w = window.open("about:blank", "MEI transcoding", 'width=700,height=820,resizeable,scrollabars,location=false');
	w.document.write(prefix + data + postfix);
	w.document.close();
	function checkTitle() {
		if (w.document) {
			w.document.title = "MEI transcoding";
		} else {
			setTimeout(checkTitle, 40);
		}
	}
	checkTitle();
	event.preventDefault();
}



//////////////////////////////
//
// getKeySig -- extract first key signature found in Humdrum data.
//

function getKeySig(text) {
	let matches;
	if (matches = text.match(/\*k\[(.*?)\]/)) {
		if (matches[1] == "b-") {
			return "&#x266d;"
		}
		return matches[1];
	} else {
		return "X";
	}
}



//////////////////////////////
//
// getMetSig -- extract first metric signature found in Humdrum data.
//

function getMetSig(text) {
	let matches;
	if (matches = text.match(/\*omet\((.*?)\)/)) {
		if (matches[1] === "C") {
			return "c";
		} else if (matches[1] === "C|") {
			return "c<span style='position:relative; top:2px; margin-left:-7px'>|</span>";
		} else {
			return matches[1];
		}
	} else {
		return "X";
	}
}



//////////////////////////////
//
// fillInTimeKey --
//

function fillInTimeKey() {
	let rows = document.querySelectorAll(".worklist tr.data");
	for (let i=0; i<rows.length; i++) {
		let idcell = rows[i].querySelector("td.id");
		let id = idcell.id;
		if (!id) {
			continue;
		}
		getTimeKey(id, rows[i]);
	}
}



//////////////////////////////
//
// getTimeKey --
//

function getTimeKey(id, row) {
	let tag = "humdrum_" + id;
	let tagcontent;
	let keysig;
	let metsig;

	let keysigcell = row.querySelector("td.keysig");
	let timecell = row.querySelector("td.time");

	if (sessionStorage[tag]) {
		keysig = getKeySig(sessionStorage[tag]);
		metsig = getMetSig(sessionStorage[tag]);
		keysigcell.innerHTML = keysig;
		timecell.innerHTML = metsig;
	} else {
		// let action = "humdrum";
		// let url = "{{site.tasso_data_url}}/?a=" + action + "&id=" + id;
		let url = `{{site.tasso_data_url_new}}/${id}.krn`;
		let request = new XMLHttpRequest();
		request.open('GET', url);
		request.addEventListener("load", function() {
			let data = this.responseText;
			sessionStorage[tag] = data;
			keysig = getKeySig(sessionStorage[tag]);
			metsig = getMetSig(sessionStorage[tag]);
			keysigcell.innerHTML = keysig;
			timecell.innerHTML = metsig;
		});
		request.send()
	}
}



//////////////////////////////
//
// toggleExpertMode --
//

let EXPERT = 0;
function toggleExpertMode() {
	EXPERT = !EXPERT;
	let elements = document.querySelectorAll(".expert");
	if (EXPERT) {
		for (let i=0; i<elements.length; i++) {
			elements[i].style["display"] = "block";
		}
	} else {
		for (i=0; i<elements.length; i++) {
			elements[i].style["display"] = "none";
		}
	}
}



//////////////////////////////
//
// toggleMensuration --
//

function toggleMensuration() {
	ORIGINAL_CLEFS = !ORIGINAL_CLEFS;
	if (ORIGINAL_CLEFS) {
		MENSURAL = false;
	}
	initializeVerovioNotation();
}



//////////////////////////////
//
// toggleMensural --
//

function toggleMensural() {
	MENSURAL = !MENSURAL;
	if (MENSURAL) {
		ORIGINAL_CLEFS = false;
	}
	initializeVerovioNotation();
}



/////////////////////////////
//
// displayMensurationState --
//

function displayMensurationState() {
	let elements = document.querySelectorAll(".mens-icon");
	let number;
	for (let i=0; i<elements.length; i++) {
		if (ORIGINAL_CLEFS) {
			elements[i].className += " highlight";
			elements[i].title = "show modern clefs/time signature (o)";
		} else {
			elements[i].classList.remove("highlight");
			elements[i].title = "show original clefs/mensuration (o)";
		}
	}
}



//////////////////////////////
//
// toggleText --
//

function toggleText() {
	INCLUDE_TEXT = !INCLUDE_TEXT;
	initializeVerovioNotation();
}



//////////////////////////////
//
// toggleAccid --
//

function toggleAccid() {
	INCLUDE_ACCID = !INCLUDE_ACCID;
	initializeVerovioNotation();
}



//////////////////////////////
//
// updateTransposition --
//

function updateTransposition() {
	let element = document.querySelector("#transpose");
	if (!element) {
		return;
	}
	TRANSPOSE = element.value;
	initializeVerovioNotation();
}



/////////////////////////////
//
// displayTextState --
//

function displayTextState() {
	let elements = document.querySelectorAll(".text-icon");
	for (let i=0; i<elements.length; i++) {
		if (INCLUDE_TEXT) {
			elements[i].classList.remove("highlight");
			elements[i].title = "hide text (t or T)";
		} else {
			elements[i].classList.add("highlight");
			elements[i].title = "show text (t)";
		}
	}
}



/////////////////////////////
//
// displayMensuralState --
//

function displayMensuralState() {
	let elements = document.querySelectorAll(".mensural-icon");
	for (let i=0; i<elements.length; i++) {
		if (MENSURAL) {
			elements[i].classList.add("highlight");
			elements[i].title = "display modern notation (m)";
		} else {
			elements[i].classList.remove("highlight");
			elements[i].title = "display mensural notation (m)";
		}
	}
}


/////////////////////////////
//
// displayAccidState --
//

function displayAccidState() {
	let elements = document.querySelectorAll(".accid-icon");
	for (let i=0; i<elements.length; i++) {
		if (INCLUDE_ACCID) {
			elements[i].classList.remove("highlight");
			elements[i].title = "hide editorial accidentals (a)";
		} else {
			elements[i].classList.add("highlight");
			elements[i].title = "show editorial accidentals (a)";
		}
	}
}



//////////////////////////////
//
// toggleCssText --
//

function toggleCssText() {
	CSS_TEXT = !CSS_TEXT;
	processCssTextState();
}




/////////////////////////////
//
// processCssTextState --
//

function processCssTextState() {
	let elements = document.querySelectorAll("svg g.syl");
	for (let i=0; i<elements.length; i++) {
		if (CSS_TEXT) {
			elements[i].style.visibility = "visible";
		} else {
			elements[i].style.visibility = "hidden";
		}
	}
}



//////////////////////////////
//
// processMusicSearch --
//

let MusicTimeout = null;
function processMusicSearch(event) {
	let queryElement = document.querySelector("#query");
	let pitchQueryElement = document.querySelector("#query-pitch");
	let intervalQueryElement = document.querySelector("#query-interval");
	let rhythmQueryElement = document.querySelector("#query-rhythm");

	let query = "";
	let pitchQuery = "";
	let intervalQuery = "";
	let rhythmQuery = "";

	if (queryElement)         { query = queryElement.value; }
	if (pitchQueryElement)    { pitchQuery = pitchQueryElement.value; }
	if (intervalQueryElement) { intervalQuery = intervalQueryElement.value; }
	if (rhythmQueryElement)   { rhythmQuery = rhythmQueryElement.value; }

	// remove quotation marks which may cause problems in command parsing:
	query          = query        .replace(/["']/, "", "g");
	pitchQquery    = pitchQuery   .replace(/["']/, "", "g");
	intervalQquery = intervalQuery.replace(/["']/, "", "g");
	rhythmQuery    = rhythmQuery  .replace(/["']/, "", "g");

	// remove leading spaces:
	query          = query        .replace(/^\s+/, "");
	pitchQquery    = pitchQuery   .replace(/^\s+/, "");
	intervalQquery = intervalQuery.replace(/^\s+/, "");
	rhythmQuery    = rhythmQuery  .replace(/^\s+/, "");

	// remove trailing spaces:
	query          = query        .replace(/\s+$/, "");
	pitchQquery    = pitchQuery   .replace(/\s+$/, "");
	intervalQquery = intervalQuery.replace(/\s+$/, "");
	rhythmQuery    = rhythmQuery  .replace(/\s+$/, "");

	let queryobj = {};

	if (query)         { queryobj.query    = query; }
	if (pitchQuery)    { queryobj.pitch    = pitchQuery; }
	if (intervalQuery) { queryobj.interval = intervalQuery; }
	if (rhythmQuery)   { queryobj.rhythm   = rhythmQuery; }

	//if (queriesMatch(queryobj, LAST_QUERY_MUSIC)) {
	//	return;
	//}

	clearTimeout(MusicTimeout);
	LAST_QUERY_MUSIC = queryobj;
	clearTimeout(MusicTimeout);
	MusicTimeout = setTimeout(function() {
		// Wait 0.0 seconds after stop typing to do search
		// since it takes a while to re-render notation.
		// Searching can be done indepdently of rendering
		// in the future to speed the display of results faster.
		initializeVerovioNotation(null, LAST_QUERY_MUSIC, LAST_QUERY_TEXT);
	}, 0);
}



//////////////////////////////
//
// queriesMatch --
//

function queriesMatch(q1, q2) {
	if (q1.query    !== q2.query)    { return false; }
	if (q1.pitch    !== q2.pitch)    { return false; }
	if (q1.interval !== q2.interval) { return false; }
	if (q1.rhythm   !== q2.rhythm)   { return false; }
	return true;
}



//////////////////////////////
//
// processTextSearch --
//

let TextTimeout = null;
function processTextSearch(event) {
	let textQueryElement = document.querySelector("#query-text");
	let textQuery = textQueryElement.value;
	textQuery = textQuery.replace(/\\s/, "", "g");
	if (textQuery == LAST_QUERY_TEXT) {
		return;
	}
	let queryobj = {};

	if (textQuery) {
		queryobj.text = textQuery;
	}
	
	LAST_QUERY_TEXT = queryobj;
	clearTimeout(TextTimeout);
	TextTimeout = setTimeout(function() {
		// Wait 0.5 seconds after stop typing to do search
		// since it takes a while to re-render notation.
		initializeVerovioNotation(null, LAST_QUERY_MUSIC, LAST_QUERY_TEXT);
	}, 500);
}



/////////////////////////////
//
// clearActiveMeasures --
//

function clearActiveMeasures(svgElement) {
	let actives = svgElement.querySelectorAll(".active");
	for (let i=0; i<actives.length; i++) {
		actives[i].classList.remove("active");
	}
}



/////////////////////////////
//
// gotoMeasure --
//

function gotoMeasure(startmeasure, endmeasure) {
	ExpandIncipit();
	let svg = document.querySelector("svg");
	clearActiveMeasures(svg);
	let measure;

	if (!endmeasure) {
		measure = svg.querySelector(".m-"+startmeasure);
		measure.classList.add("active");
		measure.scrollIntoView();
		return;
	}
	if (startmeasure >= endmeasure) {
		// Problem with the range so do nothing.
		return;
	}

	let i;
	for (i=startmeasure; i<=endmeasure; i++) {
		measure = svg.querySelector(".m-"+i);
		measure.classList.add("active");
	}
	measure = svg.querySelector(".m-"+startmeasure);
	measure.scrollIntoView();

   //let offset = $(".m-"+measurenum).offset();
  	//offset.left -= 20;
  	//offset.top -= 20;
   //console.log("OFFSET", offset);
  	// $('html, body').animate({
  	//   srollTop: offset.top,
  	//   scrollLeft: offset.left
  	// });
}



//////////////////////////////
//
// fillInDedicatee --
//

function fillInDedicatee(id) {
	let element = document.querySelector("#principal_dedicatee");
	if (!element) {
		return;
	}
	if (!SETTING.REPORT) {
		return;
	}
	let dedicatee     = SETTING.REPORT.PRINCIPAL_SOURCE_DEDICATEE;
	let dedicateeNote = SETTING.REPORT.PRINCIPAL_SOURCE_DEDICATEE_NOTE;

	let tds = element.querySelectorAll("td");
	if (tds.length != 2) {
		return;
	}
	let datatd = tds[1];

	let output = "";
	if (dedicatee) {
		output += dedicatee;
	}
	if (dedicatee && dedicateeNote) {
		output += "<br/>";
	}
	if (dedicateeNote) {
		output += dedicateeNote;
	}
	element.style.display = "display";
}



//////////////////////////////
//
// fillInOtherSources --
//

function fillInOtherSources(id) {
	let element = document.querySelector("#other_sources");
	if (!element) {
		return;
	}
	let output = "";
	let list = SETTING.REPORT.OTHER_SOURCE;
	if (!list) {
		element.innerHTML = "<div class='indent'>None</div>";
		return ;
	}
	if (!(list instanceof Array)) {
		list = [list];
	}
	output = "<div class='indent'>";
	for (let i=0; i<list.length; i++) {
		output += "<p>";
		let otherTemplate = Handlebars.compile(list[i]);
		output += otherTemplate();
	}
	output += "</div>";
	element.innerHTML = output;
}



//////////////////////////////
//
// fillInPrimarySources --
//

function fillInPrimarySources(id) {
	let element = document.querySelector("#primary_sources");
	if (!element) {
		return;
	}
	let output = "";
	let list = SETTING.REPORT.PRINCIPAL_SOURCE;
	if (!list) {
		// There is no principal source in the setting report,
		// so it will be (was) filled in automatically with the
		// princeps rism number information from sources.aton.
		return ;
	}
	if (!(list instanceof Array)) {
		list = [list];
	}
	output = "<div class='indent'>";
	for (let i=0; i<list.length; i++) {
		output += "<p>";
		let otherTemplate = Handlebars.compile(list[i]);
		output += otherTemplate();
	}
	output += "</div>";
	element.innerHTML = output;
}


//////////////////////////////
//
// showPopupHelp --
//

function showPopupHelp(url, title) {
   let newwindow = window.open(url, title,
      'left=20,top=20,width=600,height=800,resizable=no,scrollbars=no,directories=no,location=no,status=no,toolbar=no');
   // if (window.focus) {newwindow.focus()}
   return false;
}


//////////////////////////////
//
// initializeSearchBoxes --
//

function initializeSearchBoxes(cgi) {
	let queryElement         = document.querySelector("#query");
	let pitchQueryElement    = document.querySelector("#query-pitch");
	let intervalQueryElement = document.querySelector("#query-interval");
	let rhythmQueryElement   = document.querySelector("#query-rhythm");
	let textQueryElement     = document.querySelector("#query-text");

	let tstring = cgi.t || "";
	if (!tstring) {
		tstring = cgi.text || "";
	}

	let qstring = cgi.q || "";
	if (!qstring) {
		qstring = cgi.query || "";
	}

	let pstring = cgi.p || "";
	if (!pstring) {
		pstring = cgi.pitch || "";
	}

	let istring = cgi.i || "";
	if (!istring) {
		istring = cgi.interval || "";
	}

	let rstring = cgi.r || "";
	if (!rstring) {
		rstring = cgi.rhythm || "";
	}

	if (pitchQueryElement) {
		if (pstring) {
			pitchQueryElement.value = pstring;
			DISPLAYCGISEARCH = true;
		}
	}

	if (intervalQueryElement) {
		if (istring) {
			intervalQueryElement.value = istring;
			DISPLAYCGISEARCH = true;
		}
	}

	if (rhythmQueryElement) {
		if (rstring) {
			rhythmQueryElement.value = rstring;
			DISPLAYCGISEARCH = true;
		}
	}

	if (textQueryElement) {
		if (tstring) {
			textQueryElement.value = tstring;
			DISPLAYCGISEARCH = true;
		}
	}
}



</script>



