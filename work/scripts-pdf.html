<script>
// PDF generation code:
// vim: ts=3


//////////////////////////////
//
// generatePdfFull -- Write a multi-page PDF of the full score
//     in the text editor.
//

function generatePdfFull(event) {
	event.preventDefault();

	var oldOptions = vrvOptions;

	// need to explicitly disable mmOutput = 1 set by the printing process.
	oldOptions.mmOutput = 0;

	$('html').css('cursor', 'wait');
	var format = "letter";
	var orientation = "portrait";
	var width = 2159;
	var height = 2794;
	if (format === "A4") {
		width = 2100;
		height = 2970;
	} else if (format === "B3") {
		width = 2500;
		height = 3530;
	}
	if (orientation === "landscape") {
		width = [height, height = width][0];
	}
	var fontCallback = function(family, bold, italic, options) {
		if (family == "VerovioText") {
			return family;
		}
		if (family.match(/(?:^|,)\s*sans-serif\s*$/) || true) {
			if (bold && italic)    {return 'Times-BoldItalic'}
			if (bold && !italic)   {return 'Times-Bold'      }
			if (!bold && italic)   {return 'Times-Italic'    }
			if (!bold && !italic)  {return 'Times-Roman'     }
		}
	};
	var pdfOptions = {};
	pdfOptions.fontCallback = fontCallback;
	var pdf = new PDFDocument({
		useCSS:        true,
		compress:      true,
		autoFirstPage: false,
		layout:        orientation
	});
	var stream = pdf.pipe(blobStream());
	stream.on('finish', function() {
		var blob = stream.toBlob('application/pdf');
		var pdfFilename = "output.pdf";
		var pdfFilename;
		// The SAVEFILENAME should match the original filename. This needs to be
		// stored somewhere (such as in the settings index file).  Currently just
		// use the catalog ID.
		var SAVEFILENAME;
		if (SAVEFILENAME) {
			pdfFilename = SAVEFILENAME.replace(/\.[^.]*$/, "") + ".pdf";
		} else {
			if (ID) {
				pdfFilename = ID + ".pdf";
			} else {
				pdfFilename = "output.pdf";
			}
		}
		saveAs(blob, pdfFilename);
		$('html').css('cursor', 'auto');
	});
	var buffer = Uint8Array.from(atob(vrvTTF), c => c.charCodeAt(0));
	pdf.registerFont('VerovioText', buffer);
//	var buffer2 = Uint8Array.from(atob(simonettaTTF), c => c.charCodeAt(0));
//	pdf.registerFont('Simonetta', buffer2);
	var localOptions = {
		pageHeight        : height,
		pageWidth         : width,
		scale             : 97,
		spacingSystem     : 6,
		spacingStaff      : 12,
		adjustPageHeight  : 0,
		justifyVertically:  1,
		justifyIncludeLastPage: 1,
		humType           : 1,
		mmOutput          : 1,
		font              : "Leipzig",
		pageMarginLeft    : 20,
		pageMarginRight   : 20,
		pageMarginTop     : 20,
		pageMarginBottom  : 20,
		footer            : "encoded",
		header            : "encoded",
		breaks            : "auto"
	}

	var scoredata = getHumdrumSourceData();
	var staffcount = getStaffCount(scoredata[0]);
	if (CGI.filter) {
		scoredata += "\n!!!filter: " + CGI.filter + "\n";
	}
	// Need to check for staff count after filtering (so need to 
	// pull from verovio toolkit to check staff count).

	if (staffcount == 3) {
		localOptions.spacingStaff = 10;
		localOptions.spacingSystem = 12;
	} else if (staffcount == 4) {
		localOptions.spacingStaff = 15;
		localOptions.spacingSystem = 12;
	} else if (staffcount == 6) {
		localOptions.spacingStaff = 0;
		localOptions.spacingSystem = 1;
	}

console.log("PDF OPTIONS", localOptions);

	vrvToolkit.setOptions(localOptions);
	vrvToolkit.redoLayout();
	for (var i=0; i<vrvToolkit.getPageCount(); i++) {
		pdf.addPage({size: format, layout: orientation});
	 	var x = 5;
	 	var y = 10;
	 	SVGtoPDF(pdf, vrvToolkit.renderToSVG(i+1, {}).replace(/\bcurrentColor\b/g, "black"), x, y, pdfOptions);
	}

/*
	for (var i=0; i<vrvToolkit.getPageCount(); i++) {
		pdf.addPage({size: format, layout: orientation});
		var x = 5;
		var y = 10;
		var svg = vrvToolkit.renderToSVG(i+1, {});
		if (i >= 0) {
			var simonettacss = '</style>\n<style type="text/css">\n';
			simonettacss += "@font-face {\n";
			simonettacss += "   font-family: 'Simonetta';\n";
			simonettacss += "   src: url(data:application/x-font-woff;charset=uft-8;base64,";
			simonettacss += simonettaTTF;
			simonettacss += ")\t format('woff');\nfont-weight: normal;\nfont-style: normal;\n}\n";
			simonettacss += "</style>\n";
			simonettacss += '<style type="text/css">g.page-margin{font-family:Simonetta;}';
			simonettacss += ' g.tempo{font-weight:bold;} g.dir,';
			simonettacss += ' g.dynam, g.mNum{font-style:italic;} g.label{font-weight:normal;}</style>';
			svg = svg.replace("</style>", simonettacss);
			// svg = svg.replace(/font-family="Times"/g, 'font-family="Simonetta"');
			svg = svg.replace(/<tspan /g, '<tspan font-family="Simonetta" ');
			console.log("SVG XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", svg);
		}
		SVGtoPDF(pdf, svg, x, y, pdfOptions);
	}
*/

	vrvToolkit.redoLayout(oldOptions, true);
	pdf.end();
	return false;
}



//////////////////////////////
//
// getStaffCount --
//

function getStaffCount(scoredata) {
	var data = scoredata.split("\n");
	var matches;
	var counter = 0;
	for (var i=0; i<data.length; i++) {
		matches = data[i].match(/^\*\*/);
		if (!matches) {
			continue;
		}
		var fields = data[i].split("\t");
		for (var j=0; j<fields.length; j++) {
			if (fields[j] === "**kern") {
				counter++;
			}
		}
	}
	return counter;
}


</script>

{% comment %}
	Functions for saving SVG images to a PDF file.
	See demo at:
		http://pdfkit.org/demo/browser.html

	vim: ts=3:ft=javascript
{% endcomment %}


{% comment %}
	The saving process also needs FileSaver.js:
		https://github.com/eligrey/FileSaver.js
	but this is already included for saving editor contents.
{% endcomment %}



<script>

//////////////////////////////
//
// loadPdfFonts -- load all default fonts used by Verovio
//

function loadPdfFonts(pdf) {
	return RSVP.all([
		loadFontResource(pdf, 'Times', 'scripts/pdfkit/EBGaramond-Regular.ttf'),
		loadFontResource(pdf, 'TimesItalic', 'scripts/pdfkit/EBGaramond-Italic.ttf'),
		loadFontResource(pdf, 'TimesBold', 'scripts/pdfkit/EBGaramond-Bold.ttf'),
		loadFontResource(pdf, 'TimesBoldItalic', 'scripts/pdfkit/EBGaramond-BoldItalic.ttf'),
		loadFontResource(pdf, 'VerovioText', 'scripts/pdfkit/VerovioText-1.0.ttf'),
	]);
}

//////////////////////////////
//
// loadFontResource -- use font from file in pdf, returns promise
//

function loadFontResource(pdf, name, path) {
	var promise = new RSVP.Promise(function(resolve, reject) {

		var client = new XMLHttpRequest();
		client.open("GET", path);
		client.responseType = "arraybuffer";

		client.onreadystatechange = function() {
			if (this.readyState === this.DONE) {
				if (this.status === 200) {
					resolve(this.response);
				} else {
					reject(this);
				};
			}
		};

		client.send(null);
	});

	return promise.then(function(data) {
		pdf.registerFont(name, data);
		return true;
	});
}

//////////////////////////////
//
// svgFontCallback -- substitute svg fonts with pdf fonts
//

function svgFontCallback(family, bold, italic, options) {
	if (family == "VerovioText") {
		return family;
	}
	if (family.match(/(?:^|,)\s*sans-serif\s*$/) || true) {
		if (bold) {
			return (italic) ? "TimesBoldItalic" : "TimesBold";
		} else {
			return (italic) ? "TimesItalic" : "Times";
		};
	}
}


//////////////////////////////
//
// generatePdfShapshot -- Write a PDF file containing the currently displayed SVG.
//

function generatePdfSnapshot(format, orientation) {
	$('html').css('cursor', 'wait');

	var svg = document.querySelector("#output svg");
	var svgwidth = svg.getAttribute("width");
	var svgheight = svg.getAttribute("height");
	svgwidth = parseInt(svgwidth);
	svgheight = parseInt(svgheight);
	var aspect = svgheight / svgwidth;

	var format = format ? format : "letter";

	var pagewidth = 2159;
	var pageheight = 2794;
	if (format === "A4") {
		pagewidth = 2100;
		pageheight = 2970;
	} else if (format === "B3") {
		pagewidth = 2500;
		pageheight = 3530;
	}

	if (!orientation) {
		if (svgwidth > svgheight) {
			orientation = "landscape";
		}
	}
	var orientation = orientation ? orientation : "portrait";
	if (orientation === "landscape") {
		pagewidth = [pageheight, pageheight = pagewidth][0];
	}

	var pageaspect = pageheight / pagewidth;
	var scaling = 0.99;
	var mmwidth;
	var mmheight;

	if (aspect < pageaspect) {
		mmwidth = (pagewidth / 10) * scaling;
		mmheight = (pagewidth / 10) * aspect * scaling;
	} else {
		mmheight = (pageheight / 10) * scaling;
		mmwidth = (pageheight / 10) / aspect * scaling;
	}

	var pagewidthmm = pagewidth / 10.0;
	var pageheightmm = pageheight / 10.0;

	// pdf page offset (units are in mm?)
	var x = 0;
	var y = 0;

	if (mmwidth < pagewidthmm) {
		x = (pagewidthmm - mmwidth);
	}
	x += 1;

	var newspan = document.createElement("span");
	newspan.innerHTML = svg.outerHTML;
	var newsvg = newspan.querySelector("svg");

	newsvg.setAttribute("width", mmwidth + "mm");
	newsvg.setAttribute("height", mmheight + "mm");

	var pdfOptions = {};
	pdfOptions.fontCallback = svgFontCallback;
	var pdf = new PDFDocument({
		useCSS:        true,
		compress:      true,
		autoFirstPage: false,
		layout:        orientation
	});

	var stream = pdf.pipe(blobStream());
	stream.on('finish', function() {
		var blob = stream.toBlob('application/pdf');
		var pdfFilename;
		if (SAVEFILENAME) {
			pdfFilename = SAVEFILENAME.replace(/\.[^.]*$/, "") + "-snapshot.pdf";
		} else {
			pdfFilename = "snapshot.pdf";
		}
		saveAs(blob, pdfFilename);
		$('html').css('cursor', 'auto');
	});

	loadPdfFonts(pdf)
	.then(function() {
		pdf.addPage({size: format, layout: orientation});
		SVGtoPDF(pdf, newsvg, x, y, pdfOptions);
		pdf.end();
	});
}



//////////////////////////////
//
// generatePdfFull -- Write a multi-page PDF of the full score in the text editor.
//

function generatePdfFull(format, orientation) {
	var oldOptions = vrvWorker.options;
	// need to explicitly disable mmOutput = 1 set by the printing process.
	oldOptions.mmOutput = 0;

	$('html').css('cursor', 'wait');
	var format = format ? format : "letter";
	var orientation = orientation ? orientation : "portrait";

	var width = 2159;
	var height = 2794;
	if (format === "A4") {
		width = 2100;
		height = 2970;
	} else if (format === "B3") {
		width = 2500;
		height = 3530;
	}
	if (orientation === "landscape") {
		width = [height, height = width][0];
	}

	var pdfOptions = {};
	pdfOptions.fontCallback = svgFontCallback;

	var pdf = new PDFDocument({
		useCSS:        true,
		compress:      true,
		autoFirstPage: false,
		layout:        orientation
	});
	var stream = pdf.pipe(blobStream());
	stream.on('finish', function() {
		var blob = stream.toBlob('application/pdf');
		var pdfFilename = "output.pdf";

		var pdfFilename;
		if (SAVEFILENAME) {
			pdfFilename = SAVEFILENAME.replace(/\.[^.]*$/, "") + ".pdf";
		} else {
			pdfFilename = "output.pdf";
		}

		saveAs(blob, pdfFilename);

		$('html').css('cursor', 'auto');
	});

	var scale = 110;
	height /= scale / 100;
	width  /= scale / 100;

	var vrvOptions = {
		pageHeight        : height,
		pageWidth         : width,
		pageMarginLeft    : 50,
		pageMarginRight   : 50,
		pageMarginTop     : 50,
		pageMarginBottom  : 50,
		scale             : scale,
		spacingSystem     : 2,
		adjustPageHeight  : 0,
		breaks            : "auto",
		mmOutput          : 1,
		header            : "auto",
		footer            : "none",
		barLineWidth		: 0.12,
		staffLineWidth		: 0.12,
		font              : "Leipzig"
	}


	var scoredata = EDITOR.getValue().replace(/^\s+/, "");
	vrvOptions = cleanOptions2(scoredata, vrvOptions);

	RSVP.hash({
		fonts: loadPdfFonts(pdf),
		svglist: vrvWorker.renderAllPages(scoredata, vrvOptions)
	})
	.then(function(data) {
		for (var i=0; i < data.svglist.length; i++) {
			pdf.addPage({size: format, layout: orientation});
			var x = 0;
			var y = 0;
			SVGtoPDF(pdf, data.svglist[i], x, y, pdfOptions);
		}
		pdf.end();
		return true;
	})
	.finally(function() {
		// restore the old layout for the VHV  webpage:
		var force = false;
		var page = vrvWorker.page;
		var cleanoldoptions = cleanOptions2(scoredata, oldOptions);
		vrvWorker.redoLayout(oldOptions, true);
		vrvWorker.options = oldOptions;
	});
}



//////////////////////////////
//
// cleanOptions2 -- Remove options that will be processed interally from the data.
//

function cleanOptions2(content, options) {
	var lines = content.match(/[^\r\n]+/g);
	var output = options;
	var setlist = [""];
	var optionsets = {};
	optionsets[""] = {};
	var i;

	for (i=0; i<lines.length; i++) {
		var matches = lines[i].match(/^!!!verovio([^\s]*):\s*(.*)\s*$/);
		if (!matches) {
			continue;
		}
		if (matches[1] == "-parameter-group") {
			setlist.push(matches[2]);
			continue;
		}
		var mm = matches[2].match(/^\s*([^\s]+)\s+(.*)\s*$/);
		if (!mm) {
			continue;
		}
		var m = matches[1].match(/^-([^\s]+)\s*$/);
		var set = "";
		if (m) {
			set = m[1];
		}
		if (typeof optionsets[set] === 'undefined') {
			optionsets[set] = {};
		}
		optionsets[set][mm[1]] = mm[2];
	}

	for (i=0; i<setlist.length; i++) {
		if (!optionsets[setlist[i]]) {
			continue;
		}
		var keys = Object.keys(optionsets[setlist[i]]);
		var j;
		var key;
		for (j=0; j<keys.length; j++) {
			if (typeof output[keys[j]] !== 'undefined') {
				delete output[keys[j]];
			}
		}
	}

	return output;
	}

</script>



